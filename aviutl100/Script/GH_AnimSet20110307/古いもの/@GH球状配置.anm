@GH球状配置-1（定義のみ）
--track0:極スケール,0,1000,100
--track1:Xスケール,0,1000,100
--track2:Yスケール,0,1000,100
--track3:Zスケール,0,1000,100
--check0:両極のオブジェクトも描く
--
-- ●極スケール
--　　　赤道上のオブジェクトのサイズを100%と考えた場合の両極のオブジェクトのスケールを表す。
--　　　極と赤道の間のオブジェクトは、「極スケールの値〜100%」の間で段階的にリサイズされる。
--　　　オブジェクトを同じ大きさで並べると極に近いほどオブジェクトが密集するので、
--　　　それなら極に近いほどリサイズで小さくして密度を緩和してみるか〜というのが目的。
--　　　極に近いほど大きくすることもできるが、使い道は思いつかない。
--
-- ●X,Y,Zスケール
--　　　配置座標値のスケーリングを行なうもの。
--　　　オブジェクトのサイズには影響しない。
--
-- ●両極のオブジェクトも描く
--　　　両極のオブジェクトも描きます。
--　　　両極のオブジェクトは「向き」や「自転」の影響を受けないので、
--　　　描かないほうが自然な場合が多いかなと思い、デフォルトではOFFとなっています。
--
pscale=obj.track0
xscale=obj.track1
yscale=obj.track2
zscale=obj.track3
pdraw=obj.check0


@GH球状配置-2（描画）
--track0:経線頂点,1,100,10
--track1:緯線頂点,1,100,10
--track2:半径,1,5000,100
--track3:自転,-3600,3600,0
--param:dir=0;
--
-- ●経線頂点
--　　　経線上のオブジェクトの数。両極のオブジェクトは含めない。
--
-- ●緯線頂点
--　　　緯線上のオブジェクトの数。
--
-- ●向き
--　　　各オブジェクトの向きを指定します。ただし両極のオブジェクトは向きの影響を受けません。
--　　　　　0：指定なし（カメラ制御の「カメラのほうを向く」を使う場合はこれを指定して下さい）
--　　　　　1：軸の外側を向く
--　　　　　2：軸の内側を向く
--
--　　　　※本当は球面の法線を基準に外側・内側を向くモードを作りたかったけどよくわからなかった。
--　　　　　　これが俺のせいっぱい。（「俺たちのせいっぱい」でググってみるとカオスなもんが見れます。）
--　　　　　　誰かうまいこと球面に敷き詰めるようなもん作ってくれないかなあ。(ﾁﾗｯ
--
-- ●自転
--　　　自転します。ただし両極のオブジェクトは自転の影響を受けません。
--　　　（自転にあわせて回転させてしまうと向き0の時に「カメラのほうを向く」がうまく動作しなくなるため。）
--　　　両極のオブジェクトごと自転させたい場合はグループ制御のY軸回転を使うとよいかも。
--　　　ただし、その場合は軸を傾けての自転が難しくなると思います。
--
m=math.floor(obj.track0)
dm = 180/(m+1)
n=math.floor(obj.track1)
dn = 360/n
r=obj.track2
rotshift=obj.track3
dir=math.floor(dir)
for i = 1, m do
  theta=dm*i
  dm_i = theta * math.pi / 180
  -- リサイズ計算
  if(theta>90) then
    theta=180-theta
  end
  zoom=(pscale+theta/90*(100-pscale))/100
  -- 描画処理開始
  for j = 0, n-1 do
    dn_j = (dn*j/180 - 0.5 + rotshift/180) * math.pi
    x = (-r * math.sin(dm_i) * math.cos(dn_j)) * xscale/100
    z = (r * math.sin(dm_i) * math.sin(dn_j)) * zscale/100
    y = (-r * math.cos(dm_i)) * yscale/100
    ry = 0
    if(dir==1) then -- 軸の外側を向く
      ry = (360/n) * j + rotshift
    elseif(dir==2) then -- 軸の内側を向く
      ry = (360/n) * j + rotshift + 180
    end
    obj.draw(x,y,z, zoom, 1, 0,ry,0)
  end
end
if(pdraw) then -- 両極のオブジェクトを描く
  obj.draw(0,-r*yscale/100,0,pscale/100)
  obj.draw(0,r*yscale/100,0,pscale/100)  
end